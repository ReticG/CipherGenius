"""
Vulnerability Scanner
扫描密码学方案中的已知漏洞和配置问题
"""

from typing import Dict, List, Any, Optional
from enum import Enum
from dataclasses import dataclass, field
import re


class VulnerabilityCategory(Enum):
    IMPLEMENTATION = "implementation"
    CONFIGURATION = "configuration"
    CRYPTOGRAPHIC = "cryptographic"
    PROTOCOL = "protocol"
    KEY_MANAGEMENT = "key_management"


class VulnerabilitySeverity(Enum):
    CRITICAL = "critical"
    HIGH = "high"
    MEDIUM = "medium"
    LOW = "low"
    INFO = "info"

    def score(self) -> int:
        """Return numeric score for severity"""
        scores = {
            "critical": 100,
            "high": 75,
            "medium": 50,
            "low": 25,
            "info": 10
        }
        return scores.get(self.value, 0)


@dataclass
class Vulnerability:
    """Vulnerability finding"""
    id: str
    title: str
    description: str
    severity: VulnerabilitySeverity
    category: VulnerabilityCategory
    cve_ids: List[str] = field(default_factory=list)
    affected_components: List[str] = field(default_factory=list)
    remediation: str = ""
    references: List[str] = field(default_factory=list)


class VulnerabilityScanner:
    """Scan for known vulnerabilities in crypto schemes"""

    def __init__(self):
        self.vulnerability_database = self._load_vulnerability_db()
        self.weak_patterns = self._load_weak_patterns()

    def scan_scheme(self, scheme: Dict[str, Any]) -> Dict[str, Any]:
        """
        Comprehensive vulnerability scan

        Returns:
            - vulnerabilities: List of found vulnerabilities
            - risk_score: 0-100 (higher is worse)
            - summary: Counts by severity
            - recommendations: Priority fixes
        """
        vulnerabilities = []

        # Extract components from scheme
        components = self._extract_components(scheme)

        # Run all checks
        vulnerabilities.extend(self.check_known_cves(components))
        vulnerabilities.extend(self.detect_weak_patterns(scheme))
        vulnerabilities.extend(self.check_key_management(scheme))
        vulnerabilities.extend(self.check_protocol_flaws(scheme))

        # Calculate risk score
        risk_score = self._calculate_risk_score(vulnerabilities)

        # Generate summary
        summary = self._generate_summary(vulnerabilities)

        # Generate recommendations
        recommendations = self.generate_remediation_plan(vulnerabilities)

        return {
            "vulnerabilities": [self._vulnerability_to_dict(v) for v in vulnerabilities],
            "risk_score": risk_score,
            "summary": summary,
            "recommendations": recommendations,
            "total_issues": len(vulnerabilities)
        }

    def check_known_cves(self, components: List[str]) -> List[Vulnerability]:
        """Check for known CVEs affecting components"""
        vulnerabilities = []

        for component in components:
            component_lower = component.lower()

            # Check each CVE in database
            for vuln_data in self.vulnerability_database.values():
                # Check if any affected component matches
                for affected in vuln_data.get("affected_components", []):
                    if re.search(affected, component_lower, re.IGNORECASE):
                        vulnerabilities.append(Vulnerability(
                            id=vuln_data["id"],
                            title=vuln_data["title"],
                            description=vuln_data["description"],
                            severity=VulnerabilitySeverity(vuln_data["severity"]),
                            category=VulnerabilityCategory(vuln_data["category"]),
                            cve_ids=vuln_data.get("cve_ids", []),
                            affected_components=[component],
                            remediation=vuln_data.get("remediation", ""),
                            references=vuln_data.get("references", [])
                        ))
                        break

        return vulnerabilities

    def detect_weak_patterns(self, scheme: Dict[str, Any]) -> List[Vulnerability]:
        """Detect weak cryptographic patterns"""
        vulnerabilities = []

        # Convert scheme to string for pattern matching
        scheme_str = str(scheme).lower()

        for pattern_id, pattern_data in self.weak_patterns.items():
            # Check if pattern matches
            matched = False

            for pattern in pattern_data.get("patterns", []):
                if re.search(pattern, scheme_str, re.IGNORECASE):
                    matched = True
                    break

            if matched:
                # Check if any exclusion patterns exist (to avoid false positives)
                excluded = False
                for exclusion in pattern_data.get("exclusions", []):
                    if re.search(exclusion, scheme_str, re.IGNORECASE):
                        excluded = True
                        break

                if not excluded:
                    vulnerabilities.append(Vulnerability(
                        id=pattern_data["id"],
                        title=pattern_data["title"],
                        description=pattern_data["description"],
                        severity=VulnerabilitySeverity(pattern_data["severity"]),
                        category=VulnerabilityCategory(pattern_data["category"]),
                        cve_ids=pattern_data.get("cve_ids", []),
                        affected_components=pattern_data.get("affected_components", []),
                        remediation=pattern_data.get("remediation", ""),
                        references=pattern_data.get("references", [])
                    ))

        return vulnerabilities

    def check_key_management(self, scheme: Dict[str, Any]) -> List[Vulnerability]:
        """Check key management issues"""
        vulnerabilities = []

        # Check for key-related fields
        key_size = scheme.get("key_size", 0)
        algorithm = str(scheme.get("algorithm", "")).lower()
        mode = str(scheme.get("mode", "")).lower()

        # Check insufficient key size
        if "rsa" in algorithm and key_size > 0 and key_size < 2048:
            vulnerabilities.append(Vulnerability(
                id="KEY-001",
                title="Insufficient RSA Key Size",
                description=f"RSA key size of {key_size} bits is below the recommended minimum of 2048 bits",
                severity=VulnerabilitySeverity.HIGH,
                category=VulnerabilityCategory.KEY_MANAGEMENT,
                affected_components=["RSA"],
                remediation="Use RSA keys of at least 2048 bits, preferably 3072 or 4096 bits",
                references=[
                    "https://www.keylength.com/",
                    "NIST SP 800-57 Part 1"
                ]
            ))

        if "aes" in algorithm and key_size > 0 and key_size < 128:
            vulnerabilities.append(Vulnerability(
                id="KEY-002",
                title="Insufficient AES Key Size",
                description=f"AES key size of {key_size} bits is below the minimum of 128 bits",
                severity=VulnerabilitySeverity.CRITICAL,
                category=VulnerabilityCategory.KEY_MANAGEMENT,
                affected_components=["AES"],
                remediation="Use AES with at least 128-bit keys (AES-128, AES-192, or AES-256)",
                references=["NIST FIPS 197"]
            ))

        if "dsa" in algorithm and key_size > 0 and key_size < 2048:
            vulnerabilities.append(Vulnerability(
                id="KEY-003",
                title="Insufficient DSA Key Size",
                description=f"DSA key size of {key_size} bits is below the recommended minimum of 2048 bits",
                severity=VulnerabilitySeverity.HIGH,
                category=VulnerabilityCategory.KEY_MANAGEMENT,
                affected_components=["DSA"],
                remediation="Use DSA keys of at least 2048 bits or migrate to ECDSA",
                references=["NIST FIPS 186-4"]
            ))

        # Check for hardcoded keys
        if "key" in scheme or "secret" in scheme:
            key_value = scheme.get("key") or scheme.get("secret")
            if isinstance(key_value, str) and len(key_value) > 0:
                vulnerabilities.append(Vulnerability(
                    id="KEY-004",
                    title="Potential Hardcoded Key",
                    description="Detected potentially hardcoded cryptographic key",
                    severity=VulnerabilitySeverity.CRITICAL,
                    category=VulnerabilityCategory.KEY_MANAGEMENT,
                    affected_components=["Key Management"],
                    remediation="Never hardcode keys. Use secure key management systems (KMS, HSM) or environment variables",
                    references=[
                        "OWASP Top 10 - A02:2021 Cryptographic Failures",
                        "CWE-798: Use of Hard-coded Credentials"
                    ]
                ))

        # Check for key reuse indicators
        if scheme.get("iv_reuse") or scheme.get("nonce_reuse"):
            vulnerabilities.append(Vulnerability(
                id="KEY-005",
                title="IV/Nonce Reuse Detected",
                description="Reusing IVs or nonces can completely break encryption security",
                severity=VulnerabilitySeverity.CRITICAL,
                category=VulnerabilityCategory.KEY_MANAGEMENT,
                cve_ids=["CVE-2016-2107"],  # OpenSSL IV reuse
                affected_components=["Encryption"],
                remediation="Always generate fresh, random IVs/nonces for each encryption operation",
                references=[
                    "NIST SP 800-38A",
                    "CWE-323: Reusing a Nonce, Key Pair in Encryption"
                ]
            ))

        return vulnerabilities

    def check_protocol_flaws(self, scheme: Dict[str, Any]) -> List[Vulnerability]:
        """Check protocol-level vulnerabilities"""
        vulnerabilities = []

        protocol = str(scheme.get("protocol", "")).lower()
        version = str(scheme.get("version", "")).lower()
        mode = str(scheme.get("mode", "")).lower()

        # Check SSL/TLS versions
        if "ssl" in protocol or "tls" in protocol:
            if "sslv2" in version or "ssl2" in version:
                vulnerabilities.append(Vulnerability(
                    id="PROTO-001",
                    title="SSLv2 Protocol Usage",
                    description="SSLv2 is completely broken and must not be used",
                    severity=VulnerabilitySeverity.CRITICAL,
                    category=VulnerabilityCategory.PROTOCOL,
                    cve_ids=["CVE-2016-0800"],  # DROWN
                    affected_components=["SSL/TLS"],
                    remediation="Disable SSLv2 and use TLS 1.2 or TLS 1.3",
                    references=["RFC 6176 - Prohibiting SSLv2"]
                ))

            if "sslv3" in version or "ssl3" in version:
                vulnerabilities.append(Vulnerability(
                    id="PROTO-002",
                    title="SSLv3 Protocol Usage (POODLE)",
                    description="SSLv3 is vulnerable to POODLE attack",
                    severity=VulnerabilitySeverity.HIGH,
                    category=VulnerabilityCategory.PROTOCOL,
                    cve_ids=["CVE-2014-3566"],
                    affected_components=["SSL/TLS"],
                    remediation="Disable SSLv3 and use TLS 1.2 or TLS 1.3",
                    references=["https://www.openssl.org/~bodo/ssl-poodle.pdf"]
                ))

            if "tls1.0" in version or "tlsv1.0" in version:
                vulnerabilities.append(Vulnerability(
                    id="PROTO-003",
                    title="TLS 1.0 Protocol Usage (BEAST)",
                    description="TLS 1.0 is vulnerable to BEAST attack",
                    severity=VulnerabilitySeverity.MEDIUM,
                    category=VulnerabilityCategory.PROTOCOL,
                    cve_ids=["CVE-2011-3389"],
                    affected_components=["TLS"],
                    remediation="Upgrade to TLS 1.2 or TLS 1.3",
                    references=["https://www.openssl.org/docs/man1.1.1/man3/SSL_CTX_set_options.html"]
                ))

            if "tls1.1" in version or "tlsv1.1" in version:
                vulnerabilities.append(Vulnerability(
                    id="PROTO-004",
                    title="TLS 1.1 Protocol Usage",
                    description="TLS 1.1 is deprecated and should not be used",
                    severity=VulnerabilitySeverity.MEDIUM,
                    category=VulnerabilityCategory.PROTOCOL,
                    affected_components=["TLS"],
                    remediation="Upgrade to TLS 1.2 or TLS 1.3",
                    references=["RFC 8996 - Deprecating TLS 1.0 and TLS 1.1"]
                ))

        # Check for CBC mode vulnerabilities
        if "cbc" in mode:
            vulnerabilities.append(Vulnerability(
                id="PROTO-005",
                title="CBC Mode Padding Oracle Risk",
                description="CBC mode is vulnerable to padding oracle attacks if not properly implemented",
                severity=VulnerabilitySeverity.MEDIUM,
                category=VulnerabilityCategory.PROTOCOL,
                cve_ids=["CVE-2014-3566", "CVE-2016-2107"],
                affected_components=["Encryption Mode"],
                remediation="Use authenticated encryption modes like GCM or ChaCha20-Poly1305",
                references=[
                    "NIST SP 800-38D (GCM)",
                    "RFC 7539 (ChaCha20-Poly1305)"
                ]
            ))

        # Check for compression
        if scheme.get("compression") or scheme.get("compress"):
            vulnerabilities.append(Vulnerability(
                id="PROTO-006",
                title="Compression Before Encryption (CRIME/BREACH)",
                description="Compressing data before encryption can leak information",
                severity=VulnerabilitySeverity.MEDIUM,
                category=VulnerabilityCategory.PROTOCOL,
                cve_ids=["CVE-2012-4929"],  # CRIME
                affected_components=["Compression"],
                remediation="Disable compression or compress after encryption",
                references=[
                    "CRIME: https://www.imperialviolet.org/2012/09/21/crime.html",
                    "BREACH: https://breachattack.com/"
                ]
            ))

        return vulnerabilities

    def generate_remediation_plan(self, vulnerabilities: List[Vulnerability]) -> List[Dict]:
        """Generate prioritized remediation plan"""
        if not vulnerabilities:
            return []

        # Sort by severity (critical first)
        severity_order = {
            VulnerabilitySeverity.CRITICAL: 0,
            VulnerabilitySeverity.HIGH: 1,
            VulnerabilitySeverity.MEDIUM: 2,
            VulnerabilitySeverity.LOW: 3,
            VulnerabilitySeverity.INFO: 4
        }

        sorted_vulns = sorted(
            vulnerabilities,
            key=lambda v: severity_order.get(v.severity, 999)
        )

        recommendations = []
        for idx, vuln in enumerate(sorted_vulns, 1):
            recommendations.append({
                "priority": idx,
                "severity": vuln.severity.value,
                "title": vuln.title,
                "action": vuln.remediation,
                "cve_ids": vuln.cve_ids,
                "affected_components": vuln.affected_components
            })

        return recommendations

    def _load_vulnerability_db(self) -> Dict:
        """Load vulnerability database with real CVEs"""
        return {
            # SSL/TLS Vulnerabilities
            "heartbleed": {
                "id": "CVE-2014-0160",
                "title": "Heartbleed",
                "description": "OpenSSL TLS heartbeat extension buffer over-read vulnerability",
                "severity": "critical",
                "category": "implementation",
                "cve_ids": ["CVE-2014-0160"],
                "affected_components": [r"openssl.*1\.0\.1[^2-9]", r"openssl.*1\.0\.0"],
                "remediation": "Update OpenSSL to 1.0.1g or later",
                "references": [
                    "https://heartbleed.com/",
                    "https://nvd.nist.gov/vuln/detail/CVE-2014-0160"
                ]
            },
            "poodle": {
                "id": "CVE-2014-3566",
                "title": "POODLE",
                "description": "Padding Oracle On Downgraded Legacy Encryption attack against SSLv3",
                "severity": "high",
                "category": "protocol",
                "cve_ids": ["CVE-2014-3566"],
                "affected_components": [r"sslv?3", r"ssl.*3\.0"],
                "remediation": "Disable SSLv3 support, use TLS 1.2+",
                "references": [
                    "https://www.openssl.org/~bodo/ssl-poodle.pdf",
                    "https://nvd.nist.gov/vuln/detail/CVE-2014-3566"
                ]
            },
            "beast": {
                "id": "CVE-2011-3389",
                "title": "BEAST",
                "description": "Browser Exploit Against SSL/TLS - CBC mode vulnerability in TLS 1.0",
                "severity": "medium",
                "category": "protocol",
                "cve_ids": ["CVE-2011-3389"],
                "affected_components": [r"tls.*1\.0", r"ssl"],
                "remediation": "Use TLS 1.2+ or enable RC4 as workaround (not recommended long-term)",
                "references": [
                    "https://nvd.nist.gov/vuln/detail/CVE-2011-3389"
                ]
            },
            "sweet32": {
                "id": "CVE-2016-2183",
                "title": "Sweet32",
                "description": "Birthday attack against 64-bit block ciphers (DES, 3DES, Blowfish)",
                "severity": "medium",
                "category": "cryptographic",
                "cve_ids": ["CVE-2016-2183", "CVE-2016-6329"],
                "affected_components": [r"3des", r"triple.*des", r"des(?!_?ede)", r"blowfish"],
                "remediation": "Use ciphers with 128-bit blocks or larger (AES)",
                "references": [
                    "https://sweet32.info/",
                    "https://nvd.nist.gov/vuln/detail/CVE-2016-2183"
                ]
            },
            "drown": {
                "id": "CVE-2016-0800",
                "title": "DROWN",
                "description": "Decrypting RSA with Obsolete and Weakened eNcryption - SSLv2 attack",
                "severity": "critical",
                "category": "protocol",
                "cve_ids": ["CVE-2016-0800"],
                "affected_components": [r"sslv?2", r"ssl.*2\.0"],
                "remediation": "Disable SSLv2 on all servers and clients",
                "references": [
                    "https://drownattack.com/",
                    "https://nvd.nist.gov/vuln/detail/CVE-2016-0800"
                ]
            },
            "logjam": {
                "id": "CVE-2015-4000",
                "title": "Logjam",
                "description": "Weakness in Diffie-Hellman key exchange with export-grade parameters",
                "severity": "high",
                "category": "cryptographic",
                "cve_ids": ["CVE-2015-4000"],
                "affected_components": [r"dhe.*export", r"dh.*512", r"dh.*768"],
                "remediation": "Use DH parameters of at least 2048 bits or prefer ECDHE",
                "references": [
                    "https://weakdh.org/",
                    "https://nvd.nist.gov/vuln/detail/CVE-2015-4000"
                ]
            },
            "freak": {
                "id": "CVE-2015-0204",
                "title": "FREAK",
                "description": "Factoring RSA Export Keys - forces use of weak export-grade encryption",
                "severity": "high",
                "category": "cryptographic",
                "cve_ids": ["CVE-2015-0204"],
                "affected_components": [r"rsa.*export", r"rsa.*512"],
                "remediation": "Disable export cipher suites and use strong RSA keys (2048+ bits)",
                "references": [
                    "https://freakattack.com/",
                    "https://nvd.nist.gov/vuln/detail/CVE-2015-0204"
                ]
            },
            "crime": {
                "id": "CVE-2012-4929",
                "title": "CRIME",
                "description": "Compression Ratio Info-leak Made Easy - TLS compression attack",
                "severity": "medium",
                "category": "protocol",
                "cve_ids": ["CVE-2012-4929"],
                "affected_components": [r"tls.*compression", r"ssl.*compression", r"deflate"],
                "remediation": "Disable TLS/SSL compression",
                "references": [
                    "https://www.imperialviolet.org/2012/09/21/crime.html",
                    "https://nvd.nist.gov/vuln/detail/CVE-2012-4929"
                ]
            },
            "rc4_biases": {
                "id": "CVE-2013-2566",
                "title": "RC4 Cipher Biases",
                "description": "Statistical biases in RC4 keystream allow recovery of plaintext",
                "severity": "medium",
                "category": "cryptographic",
                "cve_ids": ["CVE-2013-2566", "CVE-2015-2808"],
                "affected_components": [r"rc4", r"arcfour"],
                "remediation": "Disable RC4 cipher suites, use AES-GCM or ChaCha20-Poly1305",
                "references": [
                    "RFC 7465 - Prohibiting RC4 Cipher Suites",
                    "https://nvd.nist.gov/vuln/detail/CVE-2013-2566"
                ]
            },
            "lucky13": {
                "id": "CVE-2013-0169",
                "title": "Lucky 13",
                "description": "Timing attack against TLS CBC mode padding",
                "severity": "medium",
                "category": "implementation",
                "cve_ids": ["CVE-2013-0169"],
                "affected_components": [r"cbc.*tls", r"tls.*cbc"],
                "remediation": "Use GCM or other AEAD modes, or implement constant-time operations",
                "references": [
                    "http://www.isg.rhul.ac.uk/tls/Lucky13.html",
                    "https://nvd.nist.gov/vuln/detail/CVE-2013-0169"
                ]
            },
            "md5_collision": {
                "id": "CVE-2008-1447",
                "title": "MD5 Collision Weakness",
                "description": "MD5 is cryptographically broken and susceptible to collision attacks",
                "severity": "high",
                "category": "cryptographic",
                "cve_ids": ["CVE-2008-1447"],
                "affected_components": [r"md5"],
                "remediation": "Use SHA-256 or SHA-3 instead of MD5",
                "references": [
                    "https://www.kb.cert.org/vuls/id/836068",
                    "CWE-327: Use of a Broken or Risky Cryptographic Algorithm"
                ]
            },
            "sha1_collision": {
                "id": "SHA1-COLLISION",
                "title": "SHA-1 Collision Weakness",
                "description": "SHA-1 is deprecated due to practical collision attacks (SHAttered)",
                "severity": "medium",
                "category": "cryptographic",
                "cve_ids": [],
                "affected_components": [r"sha-?1", r"sha1"],
                "remediation": "Migrate to SHA-256, SHA-384, or SHA-3",
                "references": [
                    "https://shattered.io/",
                    "NIST deprecation of SHA-1"
                ]
            },
            "roca": {
                "id": "CVE-2017-15361",
                "title": "ROCA (Return of Coppersmith's Attack)",
                "description": "Vulnerability in RSA key generation in Infineon chips",
                "severity": "critical",
                "category": "implementation",
                "cve_ids": ["CVE-2017-15361"],
                "affected_components": [r"infineon.*rsa", r"tpm.*infineon"],
                "remediation": "Replace affected RSA keys and update firmware",
                "references": [
                    "https://crocs.fi.muni.cz/public/papers/rsa_ccs17",
                    "https://nvd.nist.gov/vuln/detail/CVE-2017-15361"
                ]
            }
        }

    def _load_weak_patterns(self) -> Dict:
        """Load weak cryptographic patterns"""
        return {
            "weak_md5": {
                "id": "WEAK-001",
                "title": "Weak Hash Algorithm: MD5",
                "description": "MD5 is cryptographically broken and should not be used",
                "severity": "high",
                "category": "cryptographic",
                "patterns": [r"\bmd5\b", r"message-digest"],
                "exclusions": [r"md5.*not.*used", r"disabled.*md5"],
                "affected_components": ["Hashing"],
                "remediation": "Use SHA-256, SHA-384, SHA-512, or SHA-3",
                "references": ["RFC 6151 - Updated Security Considerations for MD5"]
            },
            "weak_sha1": {
                "id": "WEAK-002",
                "title": "Deprecated Hash Algorithm: SHA-1",
                "description": "SHA-1 is deprecated and vulnerable to collision attacks",
                "severity": "medium",
                "category": "cryptographic",
                "patterns": [r"\bsha-?1\b"],
                "exclusions": [r"sha-?256", r"sha-?384", r"sha-?512", r"sha-?3"],
                "affected_components": ["Hashing"],
                "remediation": "Migrate to SHA-256 or stronger",
                "references": ["https://shattered.io/"]
            },
            "weak_des": {
                "id": "WEAK-003",
                "title": "Obsolete Cipher: DES",
                "description": "DES has a 56-bit key size and is completely insecure",
                "severity": "critical",
                "category": "cryptographic",
                "patterns": [r"\bdes\b(?!_ede)"],
                "exclusions": [r"3des", r"triple.*des", r"des_ede"],
                "affected_components": ["Encryption"],
                "remediation": "Use AES-128 or stronger",
                "references": ["NIST withdrawal of DES"]
            },
            "weak_3des": {
                "id": "WEAK-004",
                "title": "Deprecated Cipher: 3DES/Triple DES",
                "description": "3DES uses 64-bit blocks and is vulnerable to Sweet32 attack",
                "severity": "medium",
                "category": "cryptographic",
                "patterns": [r"3des", r"triple.*des", r"des_ede"],
                "affected_components": ["Encryption"],
                "cve_ids": ["CVE-2016-2183"],
                "remediation": "Use AES-128 or stronger",
                "references": ["https://sweet32.info/"]
            },
            "weak_rc4": {
                "id": "WEAK-005",
                "title": "Broken Cipher: RC4",
                "description": "RC4 has statistical biases and is completely broken",
                "severity": "high",
                "category": "cryptographic",
                "patterns": [r"\brc4\b", r"arcfour"],
                "affected_components": ["Encryption"],
                "cve_ids": ["CVE-2013-2566", "CVE-2015-2808"],
                "remediation": "Use AES-GCM or ChaCha20-Poly1305",
                "references": ["RFC 7465 - Prohibiting RC4"]
            },
            "weak_blowfish": {
                "id": "WEAK-006",
                "title": "Deprecated Cipher: Blowfish",
                "description": "Blowfish uses 64-bit blocks and is vulnerable to birthday attacks",
                "severity": "medium",
                "category": "cryptographic",
                "patterns": [r"\bblowfish\b"],
                "affected_components": ["Encryption"],
                "cve_ids": ["CVE-2016-2183"],
                "remediation": "Use AES or its successor Twofish",
                "references": ["https://sweet32.info/"]
            },
            "ecb_mode": {
                "id": "WEAK-007",
                "title": "Insecure Mode: ECB",
                "description": "ECB mode does not provide semantic security and reveals patterns",
                "severity": "high",
                "category": "cryptographic",
                "patterns": [r"\becb\b", r"electronic.*codebook"],
                "affected_components": ["Encryption Mode"],
                "remediation": "Use CBC, CTR, or preferably GCM mode",
                "references": ["CWE-327: Use of a Broken or Risky Cryptographic Algorithm"]
            },
            "static_iv": {
                "id": "WEAK-008",
                "title": "Static IV Usage",
                "description": "Using a static IV breaks security of most encryption modes",
                "severity": "critical",
                "category": "implementation",
                "patterns": [r"static.*iv", r"fixed.*iv", r"const.*iv"],
                "affected_components": ["Initialization Vector"],
                "remediation": "Generate a fresh random IV for each encryption",
                "references": ["NIST SP 800-38A"]
            },
            "weak_rsa": {
                "id": "WEAK-009",
                "title": "Insufficient RSA Key Size",
                "description": "RSA keys below 2048 bits are considered weak",
                "severity": "high",
                "category": "key_management",
                "patterns": [r"rsa.*512", r"rsa.*1024", r"rsa.*768"],
                "affected_components": ["RSA"],
                "remediation": "Use RSA with at least 2048-bit keys",
                "references": ["NIST SP 800-57 Part 1"]
            },
            "pkcs1_v15": {
                "id": "WEAK-010",
                "title": "PKCS#1 v1.5 Padding",
                "description": "PKCS#1 v1.5 is vulnerable to Bleichenbacher attacks",
                "severity": "medium",
                "category": "cryptographic",
                "patterns": [r"pkcs1.*v?1[._]?5", r"rsa.*pkcs1(?!.*oaep)"],
                "affected_components": ["RSA Padding"],
                "remediation": "Use OAEP padding (PKCS#1 v2.0+)",
                "references": ["RFC 8017 - PKCS#1 v2.2"]
            },
            "no_authentication": {
                "id": "WEAK-011",
                "title": "Missing Authentication",
                "description": "Encryption without authentication is vulnerable to tampering",
                "severity": "high",
                "category": "cryptographic",
                "patterns": [r"cbc(?!.*hmac)", r"ctr(?!.*hmac)"],
                "exclusions": [r"gcm", r"ccm", r"eax", r"poly1305"],
                "affected_components": ["Encryption"],
                "remediation": "Use authenticated encryption (AES-GCM, ChaCha20-Poly1305) or add HMAC",
                "references": ["NIST SP 800-38D"]
            },
            "custom_crypto": {
                "id": "WEAK-012",
                "title": "Custom Cryptographic Algorithm",
                "description": "Custom or proprietary crypto is almost always insecure",
                "severity": "critical",
                "category": "cryptographic",
                "patterns": [r"custom.*cipher", r"proprietary.*crypto", r"homemade.*encryption"],
                "affected_components": ["Algorithm"],
                "remediation": "Use standard, peer-reviewed algorithms (AES, RSA, etc.)",
                "references": ["Schneier's Law: Anyone can invent a cipher they can't break"]
            }
        }

    def _extract_components(self, scheme: Dict[str, Any]) -> List[str]:
        """Extract component names from scheme"""
        components = []

        # Common fields that might contain component names
        fields = ["algorithm", "cipher", "hash", "mode", "protocol", "library", "implementation"]

        for field in fields:
            if field in scheme:
                value = scheme[field]
                if isinstance(value, str):
                    components.append(value)
                elif isinstance(value, list):
                    components.extend([str(v) for v in value])

        # Also check nested dictionaries
        for key, value in scheme.items():
            if isinstance(value, dict):
                components.extend(self._extract_components(value))

        return components

    def _calculate_risk_score(self, vulnerabilities: List[Vulnerability]) -> int:
        """Calculate overall risk score 0-100"""
        if not vulnerabilities:
            return 0

        # Weight different severity levels
        total_score = 0
        for vuln in vulnerabilities:
            total_score += vuln.severity.score()

        # Normalize to 0-100 scale
        # Cap at 100
        risk_score = min(100, total_score // len(vulnerabilities))

        return risk_score

    def _generate_summary(self, vulnerabilities: List[Vulnerability]) -> Dict[str, int]:
        """Generate summary counts by severity"""
        summary = {
            "critical": 0,
            "high": 0,
            "medium": 0,
            "low": 0,
            "info": 0
        }

        for vuln in vulnerabilities:
            summary[vuln.severity.value] += 1

        return summary

    def _vulnerability_to_dict(self, vuln: Vulnerability) -> Dict[str, Any]:
        """Convert Vulnerability to dictionary"""
        return {
            "id": vuln.id,
            "title": vuln.title,
            "description": vuln.description,
            "severity": vuln.severity.value,
            "category": vuln.category.value,
            "cve_ids": vuln.cve_ids,
            "affected_components": vuln.affected_components,
            "remediation": vuln.remediation,
            "references": vuln.references
        }
