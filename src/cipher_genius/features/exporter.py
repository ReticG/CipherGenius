"""
Export and Sharing Utilities
导出和分享密码学方案的各种格式
"""

from typing import Dict, Any, Optional
import json
import yaml
import base64
from datetime import datetime
from io import BytesIO


class SchemeExporter:
    """Export schemes to various formats"""

    def export_to_json(self, scheme: Dict[str, Any], pretty: bool = True) -> str:
        """Export scheme to JSON format

        Args:
            scheme: Scheme dictionary to export
            pretty: Whether to pretty-print the JSON

        Returns:
            JSON string representation
        """
        export_data = {
            "scheme": scheme,
            "exported_at": datetime.now().isoformat(),
            "exporter": "CipherGenius",
            "version": "1.0"
        }

        if pretty:
            return json.dumps(export_data, indent=2, ensure_ascii=False)
        else:
            return json.dumps(export_data, ensure_ascii=False)

    def export_to_markdown(self, scheme: Dict[str, Any]) -> str:
        """Export scheme to Markdown documentation

        Args:
            scheme: Scheme dictionary to export

        Returns:
            Markdown formatted string
        """
        md_parts = []

        # Header
        name = scheme.get('name', 'Unnamed Scheme')
        md_parts.append(f"# {name}\n")

        # Metadata
        md_parts.append("## Metadata\n")
        md_parts.append(f"- **Type**: {scheme.get('type', 'N/A')}")
        md_parts.append(f"- **Security Level**: {scheme.get('security_level', 'N/A')}")
        md_parts.append(f"- **Created**: {scheme.get('created_at', 'N/A')}")
        md_parts.append(f"- **Exported**: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")

        # Description
        if 'description' in scheme:
            md_parts.append("## Description\n")
            md_parts.append(f"{scheme['description']}\n")

        # Parameters
        if 'parameters' in scheme:
            md_parts.append("## Parameters\n")
            params = scheme['parameters']
            for key, value in params.items():
                md_parts.append(f"- **{key}**: `{value}`")
            md_parts.append("")

        # Algorithms
        if 'algorithms' in scheme:
            md_parts.append("## Algorithms\n")
            for algo_name, algo_code in scheme['algorithms'].items():
                md_parts.append(f"### {algo_name}\n")
                md_parts.append("```python")
                md_parts.append(algo_code)
                md_parts.append("```\n")

        # Properties
        if 'properties' in scheme:
            md_parts.append("## Properties\n")
            props = scheme['properties']
            for key, value in props.items():
                md_parts.append(f"- **{key}**: {value}")
            md_parts.append("")

        # Security Analysis
        if 'security_analysis' in scheme:
            md_parts.append("## Security Analysis\n")
            analysis = scheme['security_analysis']
            for key, value in analysis.items():
                md_parts.append(f"### {key}")
                md_parts.append(f"{value}\n")

        # Tags
        if 'tags' in scheme and scheme['tags']:
            md_parts.append("## Tags\n")
            tags = ", ".join(f"`{tag}`" for tag in scheme['tags'])
            md_parts.append(f"{tags}\n")

        # Footer
        md_parts.append("---")
        md_parts.append("*Generated by CipherGenius*")

        return "\n".join(md_parts)

    def export_to_latex(self, scheme: Dict[str, Any]) -> str:
        """Export scheme to LaTeX format for papers

        Args:
            scheme: Scheme dictionary to export

        Returns:
            LaTeX formatted string
        """
        latex_parts = []

        # Document class and packages
        latex_parts.append(r"\documentclass{article}")
        latex_parts.append(r"\usepackage[utf8]{inputenc}")
        latex_parts.append(r"\usepackage{amsmath}")
        latex_parts.append(r"\usepackage{amssymb}")
        latex_parts.append(r"\usepackage{algorithm}")
        latex_parts.append(r"\usepackage{algpseudocode}")
        latex_parts.append(r"\usepackage{listings}")
        latex_parts.append(r"\usepackage{xcolor}")
        latex_parts.append("")

        # Listings configuration
        latex_parts.append(r"\lstset{")
        latex_parts.append(r"    basicstyle=\ttfamily\small,")
        latex_parts.append(r"    keywordstyle=\color{blue},")
        latex_parts.append(r"    commentstyle=\color{gray},")
        latex_parts.append(r"    stringstyle=\color{red},")
        latex_parts.append(r"    frame=single,")
        latex_parts.append(r"    breaklines=true")
        latex_parts.append(r"}")
        latex_parts.append("")

        # Title
        name = scheme.get('name', 'Unnamed Scheme')
        latex_parts.append(f"\\title{{{self._escape_latex(name)}}}")
        latex_parts.append(r"\author{CipherGenius}")
        latex_parts.append(f"\\date{{{datetime.now().strftime('%Y-%m-%d')}}}")
        latex_parts.append("")

        latex_parts.append(r"\begin{document}")
        latex_parts.append(r"\maketitle")
        latex_parts.append("")

        # Abstract/Description
        if 'description' in scheme:
            latex_parts.append(r"\begin{abstract}")
            latex_parts.append(self._escape_latex(scheme['description']))
            latex_parts.append(r"\end{abstract}")
            latex_parts.append("")

        # Metadata
        latex_parts.append(r"\section{Metadata}")
        latex_parts.append(r"\begin{itemize}")
        latex_parts.append(f"\\item \\textbf{{Type}}: {self._escape_latex(scheme.get('type', 'N/A'))}")
        latex_parts.append(f"\\item \\textbf{{Security Level}}: {self._escape_latex(str(scheme.get('security_level', 'N/A')))}")
        latex_parts.append(f"\\item \\textbf{{Created}}: {self._escape_latex(str(scheme.get('created_at', 'N/A')))}")
        latex_parts.append(r"\end{itemize}")
        latex_parts.append("")

        # Parameters
        if 'parameters' in scheme:
            latex_parts.append(r"\section{Parameters}")
            latex_parts.append(r"\begin{itemize}")
            for key, value in scheme['parameters'].items():
                latex_parts.append(f"\\item \\textbf{{{self._escape_latex(key)}}}: \\texttt{{{self._escape_latex(str(value))}}}")
            latex_parts.append(r"\end{itemize}")
            latex_parts.append("")

        # Algorithms
        if 'algorithms' in scheme:
            latex_parts.append(r"\section{Algorithms}")
            for algo_name, algo_code in scheme['algorithms'].items():
                latex_parts.append(f"\\subsection{{{self._escape_latex(algo_name)}}}")
                latex_parts.append(r"\begin{lstlisting}[language=Python]")
                latex_parts.append(algo_code)
                latex_parts.append(r"\end{lstlisting}")
                latex_parts.append("")

        # Properties
        if 'properties' in scheme:
            latex_parts.append(r"\section{Properties}")
            latex_parts.append(r"\begin{itemize}")
            for key, value in scheme['properties'].items():
                latex_parts.append(f"\\item \\textbf{{{self._escape_latex(key)}}}: {self._escape_latex(str(value))}")
            latex_parts.append(r"\end{itemize}")
            latex_parts.append("")

        # Security Analysis
        if 'security_analysis' in scheme:
            latex_parts.append(r"\section{Security Analysis}")
            for key, value in scheme['security_analysis'].items():
                latex_parts.append(f"\\subsection{{{self._escape_latex(key)}}}")
                latex_parts.append(self._escape_latex(str(value)))
                latex_parts.append("")

        latex_parts.append(r"\end{document}")

        return "\n".join(latex_parts)

    def export_to_yaml(self, scheme: Dict[str, Any]) -> str:
        """Export scheme to YAML format

        Args:
            scheme: Scheme dictionary to export

        Returns:
            YAML formatted string
        """
        export_data = {
            "scheme": scheme,
            "exported_at": datetime.now().isoformat(),
            "exporter": "CipherGenius",
            "version": "1.0"
        }

        return yaml.dump(export_data,
                        allow_unicode=True,
                        default_flow_style=False,
                        sort_keys=False,
                        indent=2)

    def generate_pdf_report(self, scheme: Dict[str, Any],
                          include_code: bool = True) -> bytes:
        """Generate PDF report (return bytes for download)

        Args:
            scheme: Scheme dictionary to export
            include_code: Whether to include code snippets

        Returns:
            PDF file as bytes

        Note:
            This requires reportlab library. Install with: pip install reportlab
        """
        try:
            from reportlab.lib.pagesizes import letter, A4
            from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
            from reportlab.lib.units import inch
            from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, PageBreak
            from reportlab.platypus import Table, TableStyle, Preformatted
            from reportlab.lib import colors
            from reportlab.lib.enums import TA_CENTER, TA_LEFT
        except ImportError:
            # Return a simple text message if reportlab is not installed
            error_msg = "PDF generation requires reportlab library. Install with: pip install reportlab"
            return error_msg.encode('utf-8')

        # Create PDF in memory
        buffer = BytesIO()
        doc = SimpleDocTemplate(buffer, pagesize=letter,
                              rightMargin=72, leftMargin=72,
                              topMargin=72, bottomMargin=18)

        # Container for the 'Flowable' objects
        elements = []

        # Define styles
        styles = getSampleStyleSheet()
        title_style = ParagraphStyle(
            'CustomTitle',
            parent=styles['Heading1'],
            fontSize=24,
            textColor=colors.HexColor('#1a1a1a'),
            spaceAfter=30,
            alignment=TA_CENTER
        )

        heading_style = styles['Heading2']
        normal_style = styles['Normal']
        code_style = ParagraphStyle(
            'Code',
            parent=styles['Code'],
            fontSize=8,
            leftIndent=20
        )

        # Title
        name = scheme.get('name', 'Unnamed Scheme')
        elements.append(Paragraph(name, title_style))
        elements.append(Spacer(1, 12))

        # Metadata section
        elements.append(Paragraph("Metadata", heading_style))
        metadata_data = [
            ["Type:", scheme.get('type', 'N/A')],
            ["Security Level:", str(scheme.get('security_level', 'N/A'))],
            ["Created:", str(scheme.get('created_at', 'N/A'))],
            ["Exported:", datetime.now().strftime('%Y-%m-%d %H:%M:%S')]
        ]

        metadata_table = Table(metadata_data, colWidths=[2*inch, 4*inch])
        metadata_table.setStyle(TableStyle([
            ('BACKGROUND', (0, 0), (0, -1), colors.grey),
            ('TEXTCOLOR', (0, 0), (0, -1), colors.whitesmoke),
            ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
            ('FONTNAME', (0, 0), (0, -1), 'Helvetica-Bold'),
            ('FONTSIZE', (0, 0), (-1, -1), 10),
            ('BOTTOMPADDING', (0, 0), (-1, -1), 12),
            ('GRID', (0, 0), (-1, -1), 1, colors.black)
        ]))
        elements.append(metadata_table)
        elements.append(Spacer(1, 20))

        # Description
        if 'description' in scheme:
            elements.append(Paragraph("Description", heading_style))
            elements.append(Paragraph(scheme['description'], normal_style))
            elements.append(Spacer(1, 12))

        # Parameters
        if 'parameters' in scheme:
            elements.append(Paragraph("Parameters", heading_style))
            param_data = [[k, str(v)] for k, v in scheme['parameters'].items()]
            param_table = Table(param_data, colWidths=[2*inch, 4*inch])
            param_table.setStyle(TableStyle([
                ('BACKGROUND', (0, 0), (0, -1), colors.lightgrey),
                ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
                ('FONTNAME', (0, 0), (0, -1), 'Helvetica-Bold'),
                ('FONTSIZE', (0, 0), (-1, -1), 9),
                ('BOTTOMPADDING', (0, 0), (-1, -1), 8),
                ('GRID', (0, 0), (-1, -1), 1, colors.black)
            ]))
            elements.append(param_table)
            elements.append(Spacer(1, 12))

        # Algorithms (if include_code is True)
        if include_code and 'algorithms' in scheme:
            elements.append(Paragraph("Algorithms", heading_style))
            for algo_name, algo_code in scheme['algorithms'].items():
                elements.append(Paragraph(f"<b>{algo_name}</b>", normal_style))
                # Use Preformatted for code
                code_lines = algo_code.split('\n')
                for line in code_lines[:50]:  # Limit to 50 lines per algorithm
                    if line.strip():
                        elements.append(Preformatted(line, code_style))
                elements.append(Spacer(1, 12))

        # Properties
        if 'properties' in scheme:
            elements.append(Paragraph("Properties", heading_style))
            prop_data = [[k, str(v)] for k, v in scheme['properties'].items()]
            prop_table = Table(prop_data, colWidths=[2*inch, 4*inch])
            prop_table.setStyle(TableStyle([
                ('BACKGROUND', (0, 0), (0, -1), colors.lightgrey),
                ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
                ('FONTNAME', (0, 0), (0, -1), 'Helvetica-Bold'),
                ('FONTSIZE', (0, 0), (-1, -1), 9),
                ('BOTTOMPADDING', (0, 0), (-1, -1), 8),
                ('GRID', (0, 0), (-1, -1), 1, colors.black)
            ]))
            elements.append(prop_table)
            elements.append(Spacer(1, 12))

        # Security Analysis
        if 'security_analysis' in scheme:
            elements.append(PageBreak())
            elements.append(Paragraph("Security Analysis", heading_style))
            for key, value in scheme['security_analysis'].items():
                elements.append(Paragraph(f"<b>{key}</b>", normal_style))
                elements.append(Paragraph(str(value), normal_style))
                elements.append(Spacer(1, 8))

        # Footer
        elements.append(Spacer(1, 20))
        footer_style = ParagraphStyle(
            'Footer',
            parent=styles['Normal'],
            fontSize=8,
            textColor=colors.grey,
            alignment=TA_CENTER
        )
        elements.append(Paragraph("Generated by CipherGenius", footer_style))

        # Build PDF
        doc.build(elements)

        # Get the value of the BytesIO buffer
        pdf_bytes = buffer.getvalue()
        buffer.close()

        return pdf_bytes

    def create_shareable_link(self, scheme: Dict[str, Any]) -> str:
        """Create shareable link (base64 encoded scheme)

        Args:
            scheme: Scheme dictionary to share

        Returns:
            Base64 encoded string that can be used as a shareable link
        """
        # Prepare minimal scheme data for sharing
        share_data = {
            "scheme": scheme,
            "shared_at": datetime.now().isoformat(),
            "version": "1.0"
        }

        # Convert to JSON and encode
        json_str = json.dumps(share_data, ensure_ascii=False)
        encoded = base64.urlsafe_b64encode(json_str.encode('utf-8')).decode('utf-8')

        # Create shareable link format
        link = f"ciphergenius://share/{encoded}"

        return link

    def import_from_link(self, link: str) -> Dict[str, Any]:
        """Import scheme from shareable link

        Args:
            link: Shareable link created by create_shareable_link

        Returns:
            Scheme dictionary

        Raises:
            ValueError: If link format is invalid
        """
        # Validate link format
        if not link.startswith("ciphergenius://share/"):
            raise ValueError("Invalid link format. Must start with 'ciphergenius://share/'")

        # Extract encoded data
        encoded = link.replace("ciphergenius://share/", "")

        try:
            # Decode from base64
            json_str = base64.urlsafe_b64decode(encoded.encode('utf-8')).decode('utf-8')

            # Parse JSON
            share_data = json.loads(json_str)

            # Validate version
            if share_data.get('version') != "1.0":
                raise ValueError(f"Unsupported version: {share_data.get('version')}")

            # Extract scheme
            scheme = share_data.get('scheme')
            if not scheme:
                raise ValueError("No scheme data found in link")

            return scheme

        except (base64.binascii.Error, json.JSONDecodeError) as e:
            raise ValueError(f"Failed to decode link: {str(e)}")

    def _escape_latex(self, text: str) -> str:
        """Escape special LaTeX characters

        Args:
            text: Text to escape

        Returns:
            Escaped text safe for LaTeX
        """
        # LaTeX special characters that need escaping
        replacements = {
            '\\': r'\textbackslash{}',
            '&': r'\&',
            '%': r'\%',
            '$': r'\$',
            '#': r'\#',
            '_': r'\_',
            '{': r'\{',
            '}': r'\}',
            '~': r'\textasciitilde{}',
            '^': r'\textasciicircum{}'
        }

        result = text
        for char, replacement in replacements.items():
            result = result.replace(char, replacement)

        return result
